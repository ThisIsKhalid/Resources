# ðŸ§  NestJS Request Lifecycle

If we deeply understand this flow, we can:

* Debug faster
* Design cleaner architecture
* Know **where logic belongs** (and where it does NOT)

---

## ðŸ” High-Level Lifecycle (One Request)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2At5KXYUtdY1zdbqiBN1er1A.jpeg)

![Image](https://miro.medium.com/1%2ADPQb4MiOBOPkZvbDcnUhHA.png)

![Image](https://i.sstatic.net/2lFhd.jpg)

```
Client
  â†“
Middleware
  â†“
Guards
  â†“
Interceptors (before)
  â†“
Pipes
  â†“
Controller
  â†“
Service
  â†“
Interceptors (after)
  â†“
Exception Filters
  â†“
Response
```

ðŸ“˜ Official docs (bookmark this):
ðŸ‘‰ [https://docs.nestjs.com/faq/request-lifecycle](https://docs.nestjs.com/faq/request-lifecycle)

---

## 1ï¸âƒ£ Middleware (Very First Layer)

### What it is

Same concept as **Express middleware**.

### Used for:

* Logging
* Request mutation
* Headers
* Raw request handling

```ts
@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log(req.method, req.url);
    next();
  }
}
```

Applied in module:

```ts
configure(consumer: MiddlewareConsumer) {
  consumer.apply(LoggerMiddleware).forRoutes('*');
}
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/middleware](https://docs.nestjs.com/middleware)

ðŸ’¡ **Senior Rule**

> Middleware â‰  business logic
> No auth, no permissions here.

---

## 2ï¸âƒ£ Guards (Authorization Gatekeeper)

### Purpose

**Decide if request is allowed or not**

```ts
@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const req = context.switchToHttp().getRequest();
    return !!req.user;
  }
}
```

Applied:

```ts
@UseGuards(AuthGuard)
@Get()
findAll() {}
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/guards](https://docs.nestjs.com/guards)

ðŸ’¡ **Senior Rule**

> Guards answer ONE question:
> **â€œCan this request proceed?â€**

---

## 3ï¸âƒ£ Interceptors (Before & After)

### Think of Interceptors as:

* AOP (Aspect-Oriented Programming)
* Wrapping logic around execution

```ts
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    console.log('Before...');
    return next.handle().pipe(
      tap(() => console.log('After...')),
    );
  }
}
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/interceptors](https://docs.nestjs.com/interceptors)

### Used for:

* Response mapping
* Performance logging
* Caching
* Transactions

ðŸ’¡ **Senior Rule**

> If logic runs **before and after** â†’ Interceptor

---

## 4ï¸âƒ£ Pipes (Validation & Transformation)

### Pipes run **before controller method**

They:

* Validate
* Transform data

```ts
@Post()
create(@Body() dto: CreateUserDto) {}
```

With:

```ts
app.useGlobalPipes(new ValidationPipe());
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/pipes](https://docs.nestjs.com/pipes)

ðŸ’¡ **Senior Rule**

> Controllers should receive **already-valid data**

---

## 5ï¸âƒ£ Controller (Routing Only)

Controllers:

* Accept request
* Call service
* Return response

âŒ Bad controller:

```ts
@Get()
async findAll() {
  // DB logic here âŒ
}
```

âœ… Good controller:

```ts
@Get()
findAll() {
  return this.usersService.findAll();
}
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/controllers](https://docs.nestjs.com/controllers)

ðŸ’¡ **Senior Rule**

> Controllers are **traffic police**, not workers.

---

## 6ï¸âƒ£ Service (Business Logic Core)

This is where **real work happens**.

```ts
@Injectable()
export class UsersService {
  async findAll() {
    return this.repo.find();
  }
}
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/providers](https://docs.nestjs.com/providers)

ðŸ’¡ **Senior Rule**

> If it can be reused â†’ Service
> If it contains rules â†’ Service

---

## 7ï¸âƒ£ Exception Filters (Error Handling)

### If ANY error is thrownâ€¦

It goes here ðŸ‘‡

```ts
throw new NotFoundException('User not found');
```

Custom filter:

```ts
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    // format error
  }
}
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/exception-filters](https://docs.nestjs.com/exception-filters)

ðŸ’¡ **Senior Rule**

> Never return error objects manually.

---

## ðŸ§  Senior Mental Model (IMPORTANT)

| Layer       | Responsibility         |
| ----------- | ---------------------- |
| Middleware  | Raw request            |
| Guards      | Permission             |
| Pipes       | Validation             |
| Controller  | Routing                |
| Service     | Business logic         |
| Interceptor | Cross-cutting concerns |
| Filter      | Error handling         |

If you violate this â†’ **tech debt guaranteed**.

---

## ðŸ”¥ Real-World Example (Auth Request)

```
POST /users
â†“
Middleware â†’ log request
â†“
Guard â†’ JWT valid?
â†“
Interceptor â†’ start timer
â†“
Pipe â†’ validate DTO
â†“
Controller â†’ call service
â†“
Service â†’ save user
â†“
Interceptor â†’ log time
â†“
Response
```

---

## ðŸ§ª Mini Practice (Do This)

Answer **in your own words**:

1. Where should **JWT verification** live?
2. Where should **DTO validation** live?
3. Where should **DB queries** live?
4. Where should **response formatting** live?

