# ðŸ’‰ Dependency Injection (DI) in NestJS â€” Deep Dive

If we *truly* understand DI in NestJS, we can:

* Write decoupled code
* Swap implementations easily
* Test like a pro
* Design scalable architecture

---

## ðŸ§  What Dependency Injection REALLY Is

> **DI = we donâ€™t create dependencies, we receive them**

âŒ Bad (tight coupling):

```ts
const service = new UsersService();
```

âœ… Good (DI):

```ts
constructor(private readonly usersService: UsersService) {}
```

NestJS **creates, manages, and injects** dependencies for us.

ðŸ“˜ Official docs (core reading):
ðŸ‘‰ [https://docs.nestjs.com/providers](https://docs.nestjs.com/providers)

---

## ðŸ§± Providers = Anything Injectable

In NestJS, **providers** are:

* Services
* Repositories
* Factories
* Helpers
* Clients (Redis, S3, Mail)

```ts
@Injectable()
export class UsersService {}
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/fundamentals/custom-providers](https://docs.nestjs.com/fundamentals/custom-providers)

---

## ðŸ—ºï¸ Provider Scope (Senior-Level Detail)

### Default: Singleton

```ts
@Injectable()
export class AppService {}
```

One instance for whole app.

### Request-scoped

```ts
@Injectable({ scope: Scope.REQUEST })
export class RequestService {}
```

New instance **per request**.

### Transient

```ts
@Injectable({ scope: Scope.TRANSIENT })
export class TempService {}
```

New instance **every injection**.

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/fundamentals/injection-scopes](https://docs.nestjs.com/fundamentals/injection-scopes)

ðŸ’¡ **Senior Rule**

> Avoid request scope unless absolutely necessary
> (it hurts performance)

---

## ðŸ§© How NestJS Resolves Dependencies

NestJS uses a **DI Container**.

Resolution order:

1. Current module
2. Imported modules
3. Global providers

```ts
@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/modules](https://docs.nestjs.com/modules)

ðŸ’¡ **Senior Rule**

> If another module needs it â†’ export it

---

## ðŸ§ª Custom Providers (Very Important)

### 1ï¸âƒ£ `useClass` (Swap implementations)

```ts
{
  provide: PaymentService,
  useClass: StripePaymentService,
}
```

Perfect for:

* Testing
* Environment-based logic

---

### 2ï¸âƒ£ `useValue` (Constants, configs)

```ts
{
  provide: 'API_KEY',
  useValue: process.env.API_KEY,
}
```

Inject:

```ts
@Inject('API_KEY') private apiKey: string;
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/fundamentals/custom-providers#value-providers-usevalue](https://docs.nestjs.com/fundamentals/custom-providers#value-providers-usevalue)

---

### 3ï¸âƒ£ `useFactory` (Dynamic providers)

```ts
{
  provide: 'DB_CONNECTION',
  useFactory: async () => {
    return await createConnection();
  },
}
```

With dependencies:

```ts
useFactory: (config: ConfigService) => {},
inject: [ConfigService],
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)

ðŸ’¡ **Senior Use Case**
Dynamic DB, multi-tenant apps, feature flags.

---

## ðŸ·ï¸ Tokens (Class vs String vs Symbol)

| Token Type | Use                      |
| ---------- | ------------------------ |
| Class      | Default & safest         |
| String     | Legacy / constants       |
| Symbol     | Advanced, collision-free |

```ts
const LOGGER = Symbol('LOGGER');
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/fundamentals/custom-providers#non-class-based-provider-tokens](https://docs.nestjs.com/fundamentals/custom-providers#non-class-based-provider-tokens)

ðŸ’¡ **Senior Rule**

> Prefer class tokens â†’ safer refactoring

---

## ðŸŒ Global Providers

```ts
@Global()
@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
export class ConfigModule {}
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/modules#global-modules](https://docs.nestjs.com/modules#global-modules)

ðŸ’¡ **Senior Rule**

> Use global modules sparingly
> (Global = hidden dependency)

---

## ðŸ§ª DI in Testing (Senior Skill)

```ts
const moduleRef = await Test.createTestingModule({
  providers: [
    UsersService,
    {
      provide: UserRepository,
      useValue: mockRepo,
    },
  ],
}).compile();
```

ðŸ“˜ Docs:
ðŸ‘‰ [https://docs.nestjs.com/fundamentals/testing](https://docs.nestjs.com/fundamentals/testing)

ðŸ’¡ **Senior Rule**

> Mock dependencies, not the class under test

---

## ðŸ§  Senior Architecture Pattern

```
Controller
  â†“
Service
  â†“
Repository (provider)
  â†“
Database
```

Each layer depends on **abstractions**, not implementations.

---

## ðŸ§ª Practice (Do This Carefully)

Answer these like a senior:

1. Why is `new Service()` discouraged in NestJS?
2. When would you use `useFactory` instead of `useClass`?
3. Why should global modules be used carefully?
4. What provider scope is safest for performance?

