# ğŸ›¡ï¸ Advanced Authorization in NestJS

## RBAC â†’ PBAC â†’ Policy-Based Access (Senior Level)

Most apps **outgrow simple roles** very fast.
Seniors design **authorization systems that scale**.

![Image](https://cdn.sanity.io/images/3jwyzebk/production/fa22049d9c6b87e87d92d985960eecbee7fcd04f-6336x3736.png?auto=format\&fit=max\&q=75\&w=3840)

![Image](https://docs.nestjs.com/assets/Guards_1.png)

![Image](https://www.researchgate.net/publication/4232510/figure/fig1/AS%3A279593236877332%401443671630676/Policy-based-management-model-Role-Based-Access-Control-RBAC-models-5-have-received.png)

ğŸ“˜ Official NestJS Authorization docs (foundation):
ğŸ‘‰ [https://docs.nestjs.com/security/authorization](https://docs.nestjs.com/security/authorization)

---

## ğŸ§  First: Why Roles Alone FAIL

### Simple RBAC (Role-Based Access Control)

```ts
@Roles('admin')
```

Looks niceâ€¦ until:

âŒ Problems:

* `admin` does too much
* `manager` overlaps
* Role explosion (`sales-admin`, `sales-manager`, etc.)
* Hard to change permissions dynamically

ğŸ’¡ **Senior Insight**

> Roles are **coarse-grained**
> Real apps need **fine-grained control**

---

## ğŸ§© Authorization Models (Know These)

| Model                       | Used When         |
| --------------------------- | ----------------- |
| **RBAC**                    | Small apps        |
| **PBAC** (Permission-based) | Mediumâ€“large apps |
| **ABAC / Policy-based**     | Enterprise / SaaS |

Weâ€™ll evolve **RBAC â†’ PBAC â†’ Policy**

---

## 1ï¸âƒ£ Permission-Based Access Control (PBAC)

### Instead of roles:

```ts
permissions: [
  'user.read',
  'user.create',
  'deal.assign',
  'lead.change_status'
]
```

### User model (conceptual)

```
User
 â”œâ”€â”€ roles
 â”‚    â””â”€â”€ permissions[]
```

ğŸ’¡ **Senior Rule**

> Controllers should care about **permissions**, not roles

---

## 2ï¸âƒ£ Permission Decorator

```ts
export const Permissions = (...permissions: string[]) =>
  SetMetadata('permissions', permissions);
```

ğŸ“˜ Metadata reference:
ğŸ‘‰ [https://docs.nestjs.com/security/authorization#role-based-authorization](https://docs.nestjs.com/security/authorization#role-based-authorization)

---

## 3ï¸âƒ£ Permission Guard (Core Logic)

```ts
@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const required = this.reflector.get<string[]>(
      'permissions',
      context.getHandler(),
    );

    if (!required) return true;

    const req = context.switchToHttp().getRequest();
    const userPermissions = req.user.permissions;

    return required.every(p => userPermissions.includes(p));
  }
}
```

Apply:

```ts
@UseGuards(JwtAuthGuard, PermissionsGuard)
@Permissions('deal.assign')
@Post(':id/assign')
assignDeal() {}
```

ğŸ’¡ **Senior Rule**

> Guards enforce rules
> Decorators declare intent

---

## 4ï¸âƒ£ Global Permission Guard (Clean Setup)

```ts
app.useGlobalGuards(
  new JwtAuthGuard(reflector),
  new PermissionsGuard(reflector),
);
```

ğŸ“˜ Global guards:
ğŸ‘‰ [https://docs.nestjs.com/security/authentication#global-guards](https://docs.nestjs.com/security/authentication#global-guards)

ğŸ’¡ **Senior Rule**

> Prefer global guards + metadata
> Cleaner, safer, scalable

---

## 5ï¸âƒ£ Why Permissions Still Arenâ€™t Enough

Example:

> â€œA sales agent can update a deal **only if they own it**â€

This depends on:

* User
* Resource
* Context

Roles & permissions alone âŒ

---

## 6ï¸âƒ£ Policy-Based Access Control (PBAC / ABAC)

### Policy = function that decides access

```ts
export interface PolicyHandler {
  handle(user: User, resource: any): boolean;
}
```

Example policy:

```ts
export class UpdateDealPolicy implements PolicyHandler {
  handle(user: User, deal: Deal) {
    return deal.ownerId === user.id || user.role === 'admin';
  }
}
```

ğŸ’¡ **Senior Insight**

> Policies answer:
> **â€œIs THIS user allowed to act on THIS resource?â€**

---

## 7ï¸âƒ£ Policy Decorator

```ts
export const CheckPolicy = (policy: Type<PolicyHandler>) =>
  SetMetadata('policy', policy);
```

---

## 8ï¸âƒ£ Policy Guard (Very Senior)

```ts
@Injectable()
export class PoliciesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private moduleRef: ModuleRef,
  ) {}

  async canActivate(context: ExecutionContext) {
    const Policy = this.reflector.get(
      'policy',
      context.getHandler(),
    );
    if (!Policy) return true;

    const req = context.switchToHttp().getRequest();
    const resource = req.resource; // loaded earlier

    const policy = this.moduleRef.get(Policy, { strict: false });
    return policy.handle(req.user, resource);
  }
}
```

ğŸ“˜ Guards & DI reference:
ğŸ‘‰ [https://docs.nestjs.com/guards](https://docs.nestjs.com/guards)
ğŸ‘‰ [https://docs.nestjs.com/fundamentals/module-ref](https://docs.nestjs.com/fundamentals/module-ref)

---

## 9ï¸âƒ£ Real-World CRM Flow (Senior Design)

```
Request
 â†“
JwtAuthGuard
 â†“
PermissionsGuard (can update deal?)
 â†“
ResourceLoaderInterceptor (load deal)
 â†“
PoliciesGuard (does user own deal?)
 â†“
Controller
```

ğŸ’¡ **Senior Rule**

> Authorization is **layered**, not single-check

---

## ğŸš« Common Junior Mistakes

| Mistake                | Why bad             |
| ---------------------- | ------------------- |
| All logic in guard     | Unmaintainable      |
| Role checks everywhere | Inflexible          |
| No ownership checks    | Security bug        |
| Hardcoded logic        | Impossible to scale |

---

## ğŸ§  When Youâ€™re Truly Senior

You can:

* Change rules without touching controllers
* Add permissions without refactoring
* Handle multi-tenant access
* Explain **why** access was denied

---

## ğŸ§ª Senior Practice (Think Deep)

Answer these carefully:

1. Why do large systems move beyond RBAC?
2. Difference between permissions and policies?
3. Why should policies be testable units?
4. Where should resource loading happen?

